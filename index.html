<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Visual Analytics for Metric-Based Intent Recognition</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pleasejs/0.4.2/Please.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.6.1/randomColor.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <!-- Bootstrap: Latest compiled and minified CSS  -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <!-- Bootstrap: Latest compiled and minified JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        
    <style>
      table {
        table-layout: fixed;
        width: 500px;
      }

      .small_td {
        width: 110px;
        overflow-wrap: break-word;
        border-top: 1px solid lightgrey;
        padding-right: 10px;
      }

      .large_td {
        width: 350px;
        overflow-wrap: break-word;
        border-top: 1px solid lightgrey;
      }

      tr:hover {
        background-color: gainsboro;
      }

      .widget {
        border: 1px solid darkslategray; 
        box-shadow: 1px 1px 5px lightgrey;
        border-radius: 3px;
        width: fit-content; 
        padding: 10px;
        margin: 10px;
      }

      .widget_title {
        text-align: center;
        font-weight: bold;
        font-size: 1.2em;
      }

      #localAreaThreshold {
        width: 100px;
        display: inline;
      }

      input[type=number] {
        width: 50px;
      }
    </style>
  </head>
  <body>
    <!-- page content -->
    <div style="display: flex; flex-direction: row; flex-wrap: wrap; width: 100%; justify-content: space-around;">
      <div class="widget">
        <p class="widget_title">Options</p>
        
        <label for="show-errors">Show misclassifications only</label>
        <input type="checkbox" id="show-errors" name="show-errors">
        
        <div>
          <label for="show-local-words">Show localised words</label>
          <input type="checkbox" id="show-local-words" name="show-local-words" checked>
          &nbsp;|&nbsp;
          <label for="locality-shape">Locality shape</label>
          <input type="radio" name="locality-shape" value="square" checked>Square</input>
          <input type="radio" name="locality-shape" value="gaussian">Gaussian</input>
        </div>
        <div>
          <label>Frequency threshold</label>
          <input type="number" class="freqThreshold" data-index="0" value="10" />
          <input type="number" class="freqThreshold" data-index="1" value="100" />
          |&nbsp;
          <label for="localAreaThreshold">Locality threshold</label>
          <input type="range" id="localAreaThreshold" name="localAreaThreshold" min="10" max="500" value=100 step="10">
        </div>

        <div>
          <label for="dim-reduction">Position by (dimension reduction)</label>
          <input type="radio" name="dim-reduction" value="tsne" checked>t-sne</input>
          <input type="radio" name="dim-reduction" value="umap">umap</input>
        </div>

        <div>
          <label for="group-by">Colour by</label>
          <!-- <input type="radio" name="group-by" value="ground_truth_label_idx" checked>Ground truth</input>
          <input type="radio" name="group-by" value="prediction_label_idx">Prediction</input> -->
          <input type="radio" name="group-by" value="intent_cluster" checked>Intent cluster</input>
          <input type="radio" name="group-by" value="instance_cluster">Instance cluster</input>
        </div>

        <div>
          <label for="group-by">Upon select, filter by</label>
          <input type="radio" name="filter-by" value="support_set">Support set</input>
          <input type="radio" name="filter-by" value="ground_truth" checked>Same ground truth</input>
          <input type="radio" name="filter-by" value="prediction">Same prediction</input>
        </div>

        <div>
          <label for="filter">Filter datapoints by index</label>
          <input name="filter" id="filter"></input>
          <button id="clear-filter">Clear</button>
        </div>
      </div>

      <div class="widget">
        <div>
          <p class="widget_title">Filter intents</p>
          <select style="width: 300px;" size="8" name="intent_filter" id="intent_filter" multiple>
            <option value=""></option>
          </select>
        </div>
      </div>

      <div class="widget">
          <p class="widget_title">
            Table of misclassifications
          </p>
          <div style="overflow: auto; max-height: 150px;">
            <table id="confusion-table">
              <tr>
                <th column_type="gt" class="small_td">Ground truth</th>
                <th column_type="pred" class="small_td">Prediction</th>
                <th class="large_td">Text</th>
              </tr>
            </table>
          </div>
      </div>
    </div>

    <div id="container">
      <svg width="600" height="400">
      <g>
      </g>
      </svg>
    </div>

    <script>
      // set the dimensions and margins of the graph
      var margin = {top: 10, right: 30, bottom: 30, left: 60},
          width = 1400 - margin.left - margin.right,
          height = 800 - margin.top - margin.bottom;
      
      // // append the SVG object to the body of the page
      var SVG = d3.select("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .select("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");
      
      // Add a clipPath: everything out of this area won't be drawn.
      var clip = SVG.append("defs").append("SVG:clipPath")
          .attr("id", "clip")
          .append("SVG:rect")
          .attr("width", width )
          .attr("height", height )
          .attr("x", 0)
          .attr("y", 0);
    
      var drag_line = SVG.append("line")
          .attr("clip-path", "url(#clip)")
          .attr("id", "drag-line-0")
          .style("visibility", "hidden")
          .attr("stroke", "rgba(255, 112, 112, 0.8)")
          .attr("stroke-width", "3");

      var dim_reduction = "tsne";

      //Read the data
      d3.json("banking-viz-data-12-clusters.json", function(data) {
          // Parse data structure
          const cluster_to_color = d3.schemeSet3;
          const cluster_to_intent = {};
          
          data.forEach(function(d) {
            if (!cluster_to_intent[d.intent_cluster]) {
              cluster_to_intent[d.intent_cluster] = new Set([d.ground_truth])
            } else {
              cluster_to_intent[d.intent_cluster].add(d.ground_truth);
            }
          });

          // Identify errors
          errors = [];
          confusions = {};
          gt_counts = {};
          pred_counts  = {};
          errors_idxs = [];
          corrects = [];
          data.forEach((dp, idx) => {
            if (dp["ground_truth_label_idx"] != dp["prediction_label_idx"]) {
              errors.push(dp);
              errors_idxs.push(idx);

              const confusion_key = dp.ground_truth + "," + dp.prediction + "," + dp.idx;

              if (confusion_key in confusions) {
                confusions[confusion_key].push(dp.text)
              } else {
                confusions[confusion_key] = [dp.text]
              }

              if (dp.ground_truth in gt_counts) {
                gt_counts[dp.ground_truth] += 1
              } else {
                gt_counts[dp.ground_truth] = 0;
              }             
              
              if (dp.prediction in pred_counts) {
                pred_counts[dp.prediction] += 1
              } else {
                pred_counts[dp.prediction] = 0;
              }             
              
            } else if (dp["ground_truth_label_idx"] == dp["prediction_label_idx"]) {
              corrects.push(dp);
            }
          });

          // Create the table data
          const confusion_table = []
          for (confusion_key in confusions) {
            const [gt, pred, idx] = confusion_key.split(",");
            const txts = confusions[confusion_key];

            txts.forEach(txt => 
              confusion_table.push([gt, pred, txt, idx]));
          }

          confusion_table_gt_sorted = [...confusion_table];
          confusion_table_pred_sorted = [...confusion_table];

          confusion_table_gt_sorted.sort(function(row1, row2) {
            return gt_counts[row1[0]] - gt_counts[row2[0]];
          }).reverse();

          confusion_table_pred_sorted.sort(function(row1, row2) {
            return pred_counts[row1[1]] - pred_counts[row2[1]];
          }).reverse();

          // console.log(Object.entries(gt_counts).sort((a,b) => a[1] - b[1]).reverse())
          // console.log(Object.entries(pred_counts).sort((a,b) => a[1] - b[1]).reverse())

          // Create the table html from the data
          var populate_html_confusion_table = function(data) {
            var html = ""
            data.forEach(function([gt, pred, txt, idx]) {
              html += `<tr d_idx=${idx} class="error_tr">
                          <td class="small_td">${gt}</td>
                          <td class="small_td">${pred}</td>
                          <td class="large_td">${txt}</td>
                        </tr>`
              }
            );
            $("#confusion-table tr").first().after(html)
            $(".error_tr").click(function() {
              const d_idx = $(this).attr("d_idx");
              filterChart([parseInt(d_idx)]);
            })
          };

          populate_html_confusion_table(confusion_table_gt_sorted);

          $("#confusion-table th").click(function() {
            const col_type = $(this).attr("column_type");
            if (col_type == "pred") {
              populate_html_confusion_table(confusion_table_pred_sorted);
            } else if (col_type == "gt") {
              populate_html_confusion_table(confusion_table_gt_sorted);
            }
          })

          // Set up the filter feature
          $(document).ready(function() {
            dim_reduction_option = $('input[name="dim-reduction"]');
            groupby_option = $('input[name="group-by"]');
            filterby_option = $('input[name="filter-by"]');
            is_to_show_errors_only = $("#show-errors");
            is_to_show_local_words = $("#show-local-words");
            filter_input = $("#filter");
            clear_btn = $("#clear-filter");
            intent_filter = $("#intent_filter");


            // Toggle local words
            $("#show-local-words").change(function() {
              updateLocalWords(); 
            });

            // Locality shape
            $('input[name="locality-shape"]').change(function() {
              console.log($(this).val())
              updateLocalWords();
            });

            // Local area size threshold
            $("#localAreaThreshold")
              .on("mousedown", function() {
                const locality_shape = $('input[name="locality-shape"]:checked').val();
                if (locality_shape == "square") {
                  scatter.append("rect")
                    .attr("id", "localitySizer")
                    .attr("visibility", "hidden")
                    .attr("stroke", "red")
                    .attr("stroke-width", 1)
                    .attr("fill", "rgba(255, 0, 0, 0.2)")
                    .attr("x", width/2)
                    .attr("y", height/2);
                } else if (locality_shape == "gaussian") {
                  scatter.append("circle")
                    .attr("id", "localitySizer")
                    .attr("visibility", "hidden")
                    .attr("stroke", "red")
                    .attr("stroke-width", 1)
                    .attr("fill", "rgba(255, 0, 0, 0.2)")
                    .attr("cx", width/2)
                    .attr("cy", height/2);
                }
              })
              .on("mouseup", function() {
                d3.select("#localitySizer")
                  .attr("visibility", "hidden");
              })
              .on("change", function() {
                updateLocalWords();
              }).on("input", function() {
                const localitySize = $(this).val();
                d3.select("#localitySizer")
                  .attr("visibility", "visible")
                  .attr("width", localitySize)
                  .attr("height", localitySize)
                  .attr("r", localitySize)
                  .attr("x", width/2 - (localitySize/2))
                  .attr("y", height/2 - (localitySize/2) );
              });

            // Frequency threshold
            $("input.freqThreshold").change(updateLocalWords)
          
            // Intent filter
            Object.entries(cluster_to_intent).forEach(function(entry) {
              const [cluster, labels] = entry;
              const intent_set = new Set(labels);
              var optgroup_content = "";
              intent_set.forEach(intent => optgroup_content += `<option value="${intent}">${intent}</option>`);
              intent_filter.append(
                  `<optgroup label="Cluster #${cluster}">${optgroup_content}</optgroup>`
                );
            });

            intent_filter.change(function() {
              const intents = $(this).val();
              if (intents.length == 1 && intents[0] == "") {
                clear();
              } else {
                const dp_idxs = data
                    .filter(d => intents.includes(d.ground_truth))
                    .map(d => d.idx);
                filterChart(dp_idxs);
              }
              
            });

              
            // Dimension reduction method
            dim_reduction_option.change(function() {
              const dim_reduction_attr = $('input[name="dim-reduction"]:checked').val(); // TO REFACTOR: use const and let instead of var or vice versa consistently
              dim_reduction = dim_reduction_attr;
              const [x,y] = getXYScales(data);
              updatePositions(x, y);
            });

            // Group-by (colour-by) option
            groupby_option.change(function() {
              const groupby_attr = $('input[name="group-by"]:checked').val(); // TO REFACTOR: use const and let instead of var or vice versa consistently
              d3.selectAll(".datapoint")
                .style("fill", function(d) {
                  const idx = parseInt(d[groupby_attr]);
                  return cluster_to_color[idx];
                });
            });

            // Filter-by (filter-by) option
            filterby_option.change(function() {
              d = d3.select(".selected-dp").data();
              filter_by_dp_attr(d[0]);
            });

            // Show errors only?
            is_to_show_errors_only.on("change", clear);

            // Show local words?
            is_to_show_errors_only.change(function() {
              updateLocalWords();
            })

            // Drag line
            d3.select("#drag-line-0")
              .data([{"x1": 0, "y1": 0, "x2": 0, "y2": 0}]);

            // Filter input
            filter_input.on("input", function(e) {
              filter_value = e.target.value;
              filter_indices_str = filter_value.split(",");
              
              filter_indices = []
              filter_indices_str.forEach(idx => {
                idx_int = parseInt(idx)
                if (Number.isInteger(idx_int)) {
                  filter_indices.push(idx_int)
                }
              })
              
              filterChart(filter_indices)
            });

            // Clear button
            clear_btn.on("click", function(e) {
              clear();
            })
          }).keyup(function(e) {
              if (e.key === "Escape") { // escape key maps to keycode `27`
                clear();
              }
          });

          // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
          var zoom = d3.zoom()
              .scaleExtent([.8, 100])  // This control how much you can unzoom (x0.5) and zoom (x20)
              .extent([[0, 0], [width, height]])
              .on("zoom", updateChart)
              .on("start", function() {
                scatter.selectAll("text")
                .remove();
              })
              .on("end", function() {
                updateCategories();
                updateLocalWords();
              });

          // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
          SVG.append("rect")
              .attr("width", width)
              .attr("height", height)
              .style("fill", "none")
              .style("pointer-events", "all")
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
              .call(zoom);
          // now the user can zoom and it will trigger the function called updateChart

          xMin = Math.min(...data.map(d => d["tsne-dim0"]));
          xMax = Math.max(...data.map(d => d["tsne-dim0"]));
          xRange = xMax - xMin;

          yMin = Math.min(...data.map(d => d["tsne-dim1"]));
          yMax = Math.max(...data.map(d => d["tsne-dim1"]));
          yRange = yMax - yMin;


          // Add X axis
          var x = d3.scaleLinear()
          .domain([xMin - 0.1 * xRange, xMax + 0.1 * xRange])
          .range([ 0, width ]);
          var xAxis = SVG.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

          // Add Y axis
          var y = d3.scaleLinear()
          .domain([yMin - 0.1 * yRange, yMax + 0.1 * yRange])
          .range([ height, 0]);
          var yAxis = SVG.append("g")
          .call(d3.axisLeft(y));

          // Create the scatter variable
          var scatter = SVG.append('g')
          .attr("clip-path", "url(#clip)")

          // Create a drag behaviour
          var drag = d3.drag()
              .on("start", function(d) {
                const [x, y] = get_position(this);
                d3.select("#drag-line-0")
                  .attr("x1", x)
                  .attr("y1", y)
                  .attr("x2", x)
                  .attr("y2", y)
                  .style("visibility", "visible");
              })
              .on("drag", function(d) {
                d3.select("#drag-line-0")
                  .attr("x2", d3.event.x)
                  .attr("y2", d3.event.y);
              })
              .on("end", function(d) {
                mouseover_dp = d3.select(".ismouseover")
                if (mouseover_dp.empty()) {
                  d3.select("#drag-line-0").style("visibility", "hidden");
                } else {
                  const [x2, y2] = get_position(mouseover_dp.node());
                  mouseover_dp_data = mouseover_dp.data();
                  d3.select("#drag-line-0")
                  .attr("x2", x2)
                  .attr("y2", y2)
                  .data([{
                    "x1": d[`${dim_reduction}-dim0`],
                    "y1": d[`${dim_reduction}-dim1`],
                    "x2": mouseover_dp_data[0][`${dim_reduction}-dim0`],
                    "y2": mouseover_dp_data[0][`${dim_reduction}-dim1`],
                  }]);
                }
              });

          // Add triangles
          const symbolNames = ["Circle", "Cross", "Diamond",
                             "Square", "Star", "Triangle", "Wye"]

          const symbols = symbolNames.map(name => d3.symbol().type(d3[`symbol${name}`]).size(150))
          
          var customSymbolDownTriangle = { 
              draw: function(context, size){
                  let s = Math.sqrt(size);
                  context.moveTo(0,s/2);
                  context.lineTo(s,-s);
                  context.lineTo(-s,-s);
                  // context.lineTo(-s,s);
                  context.closePath();
              }
          }
     
          symbols.push(d3.symbol().type(customSymbolDownTriangle).size(100));

          scatter.selectAll('path')
            .data(data)
            .enter()
            .append('path')
            .attr("class", "datapoint")
            .attr('d', d3.symbol().type(d3.symbolCircle).size(150))
            .attr("stroke", "lightslategrey")
            .attr('fill',  function (d) {
              var label = parseInt(d["intent_cluster"])
              return cluster_to_color[label]; 
            })
            .attr('transform', function(d) {
              translation = "translate(" + x(d[`${dim_reduction}-dim0`])
                   + "," + y(d[`${dim_reduction}-dim1`]) + ")";
              return translation;
            })
            .on("mouseover", show_tooltip)
            .on("mousemove", move_tooltip_to_cursor)
            .on("mouseout", hide_tooltip)
            .on("click", onclick)
            .call(drag);

          // Initialise a variable for keeping track of currently visible datapoints
          var currently_visible_dps = scatter.selectAll(".datapoint");

          // create a tooltip
          var tooltip = d3.select("#container")
            .append("div")
              .style("position", "absolute")
              .style("visibility", "hidden")
              .style("background-color", "white")
              .style("border", "2px solid black")
              .style("padding", "10px")

          updateLocalWords();

          // A function that counts word frequency in all visible dps
          function updateLocalWords() {
            const is_to_show_local_words = $("#show-local-words").is(":checked");
            const locality_threshold = $("#localAreaThreshold").val();
            const freq_threshold_lower = $("input.freqThreshold[data-index=0]").val();
            const freq_threshold_upper = $("input.freqThreshold[data-index=1]").val();

            if (!is_to_show_local_words) {
              scatter.selectAll("text").remove();
              return;
            }

            var [visibles, gold_intent_set, predicted_intent_set] = getVisibleDatapoints(); // TO REFACTOR: reduce the call to getVisibleDatapoints() when updateCategories is called in the same context
            var word_positions = {}

            visibles.each(function(d) {
              const pos_x = this.transform.baseVal[0].matrix.e;
              const pos_y = this.transform.baseVal[0].matrix.f;
              const txt = d.text;
              const words = txt.match(/\b(\w+)\b/g);
              words.forEach(function(word) {
                if (word in word_positions) {
                  word_positions[word].push([pos_x, pos_y])
                } else {
                  word_positions[word] = [[pos_x, pos_y]]
                }
              });
            });

            word_positions = Object.entries(word_positions)
        
            const locality_shape = $('input[name="locality-shape"]:checked').val();
            var locality_fn = null;
            if (locality_shape == "square") {
              locality_fn = filterLocalWordsWithSquareLocality;
            } else if (locality_shape == "gaussian") {
              locality_fn = filterLocalWordsWithGaussianLocality;
            }

            // if a word is localised, then we display that word there
            const localised_words = locality_fn(
                word_positions,
                freq_threshold_lower,
                freq_threshold_upper,
                locality_threshold
              )

            scatter.selectAll(".local_word").remove();
            scatter.selectAll("text")
                .data(localised_words)
                .enter()
                .append("text")
                .attr("class", "local_word")
                .text(d => d.word)
                .style("font-size", d => (10 + d.frequency) + "px")
                .attr("x", function(d) {                 
                  return d.position[0]; // - this.getBBox().width/2;
                })
                .attr("y", function(d) {
                  return d.position[1]; //+ this.getBBox().height/2;
                })
                .style("fill", "#001617")
          }

          function filterLocalWordsWithSquareLocality(word_positions,
                                                      freq_threshold_lower,
                                                      freq_threshold_upper,
                                                      locality_threshold) {
            const localised_words = [];
            word_positions.forEach(function(entry) {
              const [word, positions] = entry;
              const xs = [];
              const ys = [];
              positions.forEach(function(pos) {
                const [x,y] = pos;
                xs.push(x);
                ys.push(y);
              })

              const [max_x, min_x] = [Math.max(...xs), Math.min(...xs)];
              const [max_y, min_y] = [Math.max(...ys), Math.min(...ys)];

              const x_range = max_x - min_x;
              const y_range = max_y - min_y;
              
              if (positions.length >= freq_threshold_lower
                  && positions.length <= freq_threshold_upper
                  && x_range < locality_threshold 
                  && y_range < locality_threshold) {
                localised_words.push({
                  "word": word,
                  "frequency": positions.length,
                  "position": [min_x + x_range/2, min_y + y_range/2]
                });
              }
            });
            return localised_words;
          }

          function filterLocalWordsWithGaussianLocality(word_positions,
                                                      freq_threshold_lower,
                                                      freq_threshold_upper,
                                                      locality_threshold) {
            // Assume the positions are normally distributed
            var get_mean = function(samples) {
              const sum = samples.reduce((a,b) => a+b, 0);
              const mean = sum / samples.length;
              return mean;
            } 

            var get_std = function(samples, mean) {
              const acc = samples.reduce((a,b) => a + (b - mean)**2, 0);
              return Math.sqrt(acc / (samples.length - 1));
            }

            var get_zscore = function(sample, mean, std) {
              return (sample - mean) / std;
            }

            const localised_words = [];
            word_positions.forEach(function(entry) {
              const [word, positions] = entry;
              if (positions.length <= 1) return; 
              const xs = [];
              const ys = [];
              positions.forEach(function(pos) {
                const [x,y] = pos;
                xs.push(x);
                ys.push(y);
              })

              const [mean_x, mean_y] = [get_mean(xs), get_mean(ys)];
              const [std_x, std_y] = [
                get_std(xs, mean_x),
                get_std(ys, mean_y)
              ] 

              // if the word is frequent enough and 
              // if 2*std is in locality threshold
              if (positions.length >= freq_threshold_lower
                  && positions.length <= freq_threshold_upper
                  && 2 * std_x < locality_threshold 
                  && 2 * std_y < locality_threshold) {
                localised_words.push({
                  "word": word,
                  "frequency": positions.length,
                  "position": [mean_x, mean_y],
                });
              }
            });
            return localised_words;
          }

          // A function that updates the chart when the user zoom and thus new boundaries are available
          function updateChart() {
              // recover the new scale
              var newX = d3.event.transform.rescaleX(x);
              var newY = d3.event.transform.rescaleY(y);

              // update axes with these new boundaries
              xAxis.call(d3.axisBottom(newX))
              yAxis.call(d3.axisLeft(newY))
              
              updatePositions(newX, newY);

              var drag_link = d3.select("#drag-line-0");
              if (!drag_link.empty() && drag_link.style("visibility") == "visible") {
                drag_link
                .attr("x1", function(d) { return newX(d.x1) })
                .attr("y1", function(d) { return newY(d.y1) })
                .attr("x2", function(d) { return newX(d.x2) })
                .attr("y2", function(d) { return newY(d.y2) });
              }    
          }

          function getXYScales(data) { // TO REFACTOR: use this instead of repetition
            xMin = Math.min(...data.map(d => d[`${dim_reduction}-dim0`]));
            xMax = Math.max(...data.map(d => d[`${dim_reduction}-dim0`]));
            xRange = xMax - xMin;

            yMin = Math.min(...data.map(d => d[`${dim_reduction}-dim1`]));
            yMax = Math.max(...data.map(d => d[`${dim_reduction}-dim1`]));
            yRange = yMax - yMin;


            // Add X axis
            var x = d3.scaleLinear()
            .domain([xMin - 0.1 * xRange, xMax + 0.1 * xRange])
            .range([ 0, width ]);

            // Add Y axis
            var y = d3.scaleLinear()
            .domain([yMin - 0.1 * yRange, yMax + 0.1 * yRange])
            .range([ height, 0]);

            return [x, y];
          }

          function updatePositions(xScale, yScale) {
            // update positions
            scatter
              .selectAll("path.datapoint")
              .attr('transform', function(d) {
                translation = "translate(" + xScale(d[`${dim_reduction}-dim0`])
                    + "," + yScale(d[`${dim_reduction}-dim1`]) + ")";
                return translation;
              });
          }

          function updateCategories() {
            var [visibles, gold_intent_set, predicted_intent_set] = getVisibleDatapoints();

            currently_visible_dps = visibles;

            if (gold_intent_set.length <= symbols.length) {
              const intents_with_symbols = Object.keys(previous_intent_symbol_map)
                                              .map(k => parseInt(k))
                                              .filter(k => gold_intent_set.includes(k));
              const intents_without_symbols = gold_intent_set.filter(
                  intent => !intents_with_symbols.includes(intent)
                );
              const used_symbols = intents_with_symbols.map(k => previous_intent_symbol_map[k]);
              const remaining_symbols = symbols.filter(sym =>
                  !used_symbols.includes(sym)
                );

              if (intents_without_symbols.length > remaining_symbols.length) {
                throw new Error("There aren't enough symbols to assign to the newly visible intents: "
                                  + `${intents_without_symbols.length} !< ${remaining_symbols.length}`);
              }


              intent_to_symbol = Object.fromEntries( intents_without_symbols.map((intent, i) => [intent, remaining_symbols[i]]) );
              currently_visible_dps
                .attr("d", function(d) {
                  const intent = d.ground_truth_label_idx;
                  if (intents_with_symbols.includes(intent)) {
                    return previous_intent_symbol_map[intent](d);
                  } else {
                    return intent_to_symbol[intent](d);
                  }
                })
              
              previous_intent_symbol_map = Object.assign(previous_intent_symbol_map, intent_to_symbol);
            } else {
              currently_visible_dps
                .attr("d", d3.symbol().type(d3.symbolCircle).size(150));
            }
          }

          var previous_intent_symbol_map = {};

          function getVisibleDatapoints() {
            var gold_intents = [];
            var predicted_intents = [];

            visibles = scatter.selectAll(".datapoint").filter(function(d) {
              var x = this.transform.baseVal[0].matrix.e;
              var y = this.transform.baseVal[0].matrix.f;
              
              is_visible = d3.select(this).style("visibility") == "visible"
              is_visible = is_visible && 0 < x && x < width && 0 < y && y < height;
              if (is_visible) {
                gold_intents.push(d["ground_truth_label_idx"])
                predicted_intents.push(d["prediction_label_idx"])
              }
              return is_visible;
            });

            var gold_intent_set = [...new Set(gold_intents)];
            var predicted_intent_set = [...new Set(predicted_intents)];

            return [visibles, Array.from(gold_intent_set), Array.from(predicted_intent_set)];
          }

          function filterChart(idxs) {
            const is_to_show_errors_only = ($("#show-errors").is(":checked"));

            var filtered_idxs;
            if (is_to_show_errors_only) {
              if (idxs.length == 0) {
                filtered_idxs = errors_idxs;
              } else {
                filtered_idxs = errors_idxs.filter(i => idxs.includes(i));
              }
            } else {
              if (idxs.length == 0) {
                filtered_idxs = data.map(d => d.idx);
              } else {
                filtered_idxs = idxs;
              }
            }
            d3.selectAll(".datapoint")
              .attr("visibility", function(d) {
                if (filtered_idxs.includes(d.idx)) {
                  return "visible"; // TO REFACTOR: use semi-colons consistently
                } else {
                  return "hidden";
                }
              });

            updateLocalWords();
          }

          function clear() {
            filter_input.val("");
            if ($("#show-errors").is(":checked")) {
              filterChart(errors_idxs);
            } else {
              
            }
            filterChart([]);

            $(".selected-dp")
              .attr("stroke", "darkgrey")
              .attr("stroke-width", "1px")
              .removeClass("selected-dp");
            d3.select("#drag-line-0").style("visibility", "hidden");
          }

          function show_tooltip(d) { // TO REFACTOR: use either camelCase or snake_case but not both
            move_tooltip_to_cursor();
            $(this).addClass("ismouseover");
            tooltip_html = Object.entries(d).reduce(
              (acc, current) => acc + `<p><b>${ current[0] }</b>: ${ current[1] }</p>`,
              ""
            );
            tooltip.html(tooltip_html);
            return tooltip.style("visibility", "visible");
          }

          function move_tooltip_to_cursor() { 
            return tooltip.style("top", (event.pageY + 20)+"px").style("left",(event.pageX + 20)+"px");
          }

          function hide_tooltip(){ 
            $(this).removeClass("ismouseover");
            return tooltip.style("visibility", "hidden");
          }

          /*
          Return the position of the given circle/triangle
          */
          function get_position(dp_element) {
            return [dp_element.transform.baseVal[0].matrix.e,
                    dp_element.transform.baseVal[0].matrix.f];
          }

          function onclick(d) {
            $(".selected-dp")
              .removeClass("selected-dp")
              .attr("stroke", "darkgrey")
              .attr("stroke-width", "1px");
            filter_by_dp_attr(d);
            $(this).attr("stroke", "red")
                  .attr("stroke-width","3px")
                  .addClass("selected-dp");
          }

          function filter_by_dp_attr(d) {
            if (!d) {
              return;
            }

            const filter_by = $('input[name="filter-by"]:checked').val(); 
            var idxs = [];
            if (filter_by == "support_set") {
              idxs = d[filter_by].concat([d["idx"]]);
            } else {
              data.forEach(function(dp, i) {
                if (dp[filter_by] == d[filter_by]) {
                  idxs.push(i);
                }
              });
            }
            filterChart(idxs);
            updateCategories();
          }
      })

    </script>
  </body>
</html>