<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Visual Analytics for Metric-Based Intent Recognition</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pleasejs/0.4.2/Please.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.6.1/randomColor.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
  </head>
  <body>
    <!-- page content -->

    <label for="show-errors">Show misclassifications only</label>
    <input type="checkbox" id="show-errors" name="show-errors">
    
    &nbsp; | &nbsp;
    <label for="dim-reduction">Position by (dimension reduction)</label>
    <input type="radio" name="dim-reduction" value="tsne" checked>t-sne</input>
    <input type="radio" name="dim-reduction" value="umap">umap</input>


    &nbsp; | &nbsp;
    <label for="group-by">Colour by</label>
    <!-- <input type="radio" name="group-by" value="ground_truth_label_idx" checked>Ground truth</input>
    <input type="radio" name="group-by" value="prediction_label_idx">Prediction</input> -->
    <input type="radio" name="group-by" value="intent_cluster" checked>Intent cluster</input>
    <input type="radio" name="group-by" value="instance_cluster">Instance cluster</input>
    

    &nbsp; | &nbsp;
    <label for="filter">Filter datapoints by index</label>
    <input name="filter" id="filter"></input>
    <button id="clear-filter">Clear</button>

    &nbsp; | &nbsp;
    <label for="group-by">Upon select, filter by</label>
    <input type="radio" name="filter-by" value="support_set">Support set</input>
    <input type="radio" name="filter-by" value="ground_truth" checked>Ground-truth</input>
    <input type="radio" name="filter-by" value="prediction">Prediction</input>
    
    &nbsp; | &nbsp;
    <label for="intent_filter">Filter intents</label>
    <select name="intent_filter" id="intent_filter">
      <option value=""></option>
    </select>

    <div id="container">
      <svg width="600" height="400">
      <g>
      </g>
      </svg>
    </div>
    

    <script>
      // set the dimensions and margins of the graph
      var margin = {top: 10, right: 30, bottom: 30, left: 60},
          width = 1400 - margin.left - margin.right,
          height = 1000 - margin.top - margin.bottom;
      
      // // append the SVG object to the body of the page
      var SVG = d3.select("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .select("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");
      
      // Add a clipPath: everything out of this area won't be drawn.
      var clip = SVG.append("defs").append("SVG:clipPath")
          .attr("id", "clip")
          .append("SVG:rect")
          .attr("width", width )
          .attr("height", height )
          .attr("x", 0)
          .attr("y", 0);
    
      var drag_line = SVG.append("line")
          .attr("clip-path", "url(#clip)")
          .attr("id", "drag-line-0")
          .style("visibility", "hidden")
          .attr("stroke", "rgba(255, 112, 112, 0.8)")
          .attr("stroke-width", "3");

      var dim_reduction = "tsne"; // default is umap

      //Read the data
      d3.json("viz-data.json", function(data) {
          // Parse data structure
          const cluster_to_color = d3.schemeSet3;
          const cluster_to_intent = {};
          
          data.forEach(function(d) {
            if (!cluster_to_intent[d.intent_cluster]) {
              cluster_to_intent[d.intent_cluster] = new Set([d.ground_truth])
            } else {
              cluster_to_intent[d.intent_cluster].add(d.ground_truth);
            }
          });

          const intent_filter = $("#intent_filter");
          Object.entries(cluster_to_intent).forEach(function(entry) {
            const [cluster, labels] = entry;
            const intent_set = new Set(labels);
            var optgroup_content = "";
            intent_set.forEach(intent => optgroup_content += `<option value="${intent}">${intent}</option>`);
            intent_filter.append(
                `<optgroup label="Cluster #${cluster}">${optgroup_content}</optgroup>`
              );
          });

          
          
          intent_filter.change(function() {
            const value = $(this).val();
            d3.selectAll(".datapoint")
              .style("visibility", function(d) {
                if (d.ground_truth == value) {
                  return "visible";
                } else {
                  return "hidden";
                }
              })
          })

          // Identify errors
          errors = [];
          errors_idxs = [];
          corrects = [];
          data.forEach((dp, idx) => {
            if (dp["ground_truth_label_idx"] != dp["prediction_label_idx"]) {
              errors.push(dp);
              errors_idxs.push(idx);
            } else if (dp["ground_truth_label_idx"] == dp["prediction_label_idx"]) {
              corrects.push(dp);
            }
          });

          // Set up the filter feature
          $(document).ready(function(){
            dim_reduction_option = $('input[name="dim-reduction"]');
            groupby_option = $('input[name="group-by"]');
            filterby_option = $('input[name="filter-by"]');
            is_to_show_errors_only = $("#show-errors")
            filter_input = $("#filter");
            clear_btn = $("#clear-filter");

            // Dimension reduction method
            dim_reduction_option.change(function() {
              const dim_reduction_attr = $('input[name="dim-reduction"]:checked').val(); // TO REFACTOR: use const and let instead of var or vice versa consistently
              dim_reduction = dim_reduction_attr;
              const [x,y] = getXYScales(data);
              updatePositions(x, y);
            });

            // Group-by (colour-by) option
            groupby_option.change(function() {
              const groupby_attr = $('input[name="group-by"]:checked').val(); // TO REFACTOR: use const and let instead of var or vice versa consistently
              d3.selectAll(".datapoint")
                .style("fill", function(d) {
                  const idx = parseInt(d[groupby_attr]);
                  return cluster_to_color[idx];
                });
            });

            // Filter-by (filter-by) option
            filterby_option.change(function() {
              d = d3.select(".selected-dp").data();
              filter_by_dp_attr(d[0]);
            });

            // Show errors only?
            is_to_show_errors_only.on("change", clear);

            // Drag line
            d3.select("#drag-line-0")
              .data([{"x1": 0, "y1": 0, "x2": 0, "y2": 0}]);

            // Filter input
            filter_input.on("input", function(e) {
              filter_value = e.target.value;
              filter_indices_str = filter_value.split(",");
              
              filter_indices = []
              filter_indices_str.forEach(idx => {
                idx_int = parseInt(idx)
                if (Number.isInteger(idx_int)) {
                  filter_indices.push(idx_int)
                }
              })
              
              filterChart(filter_indices)
            });

            // Clear button
            clear_btn.on("click", function(e) {
              clear();
            })
          }).keyup(function(e) {
              if (e.key === "Escape") { // escape key maps to keycode `27`
                clear();
              }
          });

          // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
          var zoom = d3.zoom()
              .scaleExtent([.8, 100])  // This control how much you can unzoom (x0.5) and zoom (x20)
              .extent([[0, 0], [width, height]])
              .on("zoom", updateChart)
              .on("end", updateCategories);

          // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
          SVG.append("rect")
              .attr("width", width)
              .attr("height", height)
              .style("fill", "none")
              .style("pointer-events", "all")
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
              .call(zoom);
          // now the user can zoom and it will trigger the function called updateChart

          xMin = Math.min(...data.map(d => d["tsne-dim0"]));
          xMax = Math.max(...data.map(d => d["tsne-dim0"]));
          xRange = xMax - xMin;

          yMin = Math.min(...data.map(d => d["tsne-dim1"]));
          yMax = Math.max(...data.map(d => d["tsne-dim1"]));
          yRange = yMax - yMin;


          // Add X axis
          var x = d3.scaleLinear()
          .domain([xMin - 0.1 * xRange, xMax + 0.1 * xRange])
          .range([ 0, width ]);
          var xAxis = SVG.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

          // Add Y axis
          var y = d3.scaleLinear()
          .domain([yMin - 0.1 * yRange, yMax + 0.1 * yRange])
          .range([ height, 0]);
          var yAxis = SVG.append("g")
          .call(d3.axisLeft(y));

          // Create the scatter variable
          var scatter = SVG.append('g')
          .attr("clip-path", "url(#clip)")

          // Create a drag behaviour
          var drag = d3.drag()
              .on("start", function(d) {
                const [x, y] = get_position(this);
                d3.select("#drag-line-0")
                  .attr("x1", x)
                  .attr("y1", y)
                  .attr("x2", x)
                  .attr("y2", y)
                  .style("visibility", "visible");
              })
              .on("drag", function(d) {
                d3.select("#drag-line-0")
                  .attr("x2", d3.event.x)
                  .attr("y2", d3.event.y);
              })
              .on("end", function(d) {
                mouseover_dp = d3.select(".ismouseover")
                if (mouseover_dp.empty()) {
                  d3.select("#drag-line-0").style("visibility", "hidden");
                } else {
                  const [x2, y2] = get_position(mouseover_dp.node());
                  mouseover_dp_data = mouseover_dp.data();
                  d3.select("#drag-line-0")
                  .attr("x2", x2)
                  .attr("y2", y2)
                  .data([{
                    "x1": d[`${dim_reduction}-dim0`],
                    "y1": d[`${dim_reduction}-dim1`],
                    "x2": mouseover_dp_data[0][`${dim_reduction}-dim0`],
                    "y2": mouseover_dp_data[0][`${dim_reduction}-dim1`],
                  }]);
                }
              });

          // Add triangles
          const symbolNames = ["Circle", "Cross", "Diamond",
                             "Square", "Star", "Triangle", "Wye"]

          const symbols = symbolNames.map(name => d3.symbol().type(d3[`symbol${name}`]).size(150))
          
          var customSymbolDownTriangle = { 
              draw: function(context, size){
                  let s = Math.sqrt(size);
                  context.moveTo(0,s/2);
                  context.lineTo(s,-s);
                  context.lineTo(-s,-s);
                  // context.lineTo(-s,s);
                  context.closePath();
              }
          }
     
          symbols.push(d3.symbol().type(customSymbolDownTriangle).size(100));

          scatter.selectAll('path')
            .data(data)
            .enter()
            .append('path')
            .attr("class", "datapoint")
            .attr('d', d3.symbol().type(d3.symbolCircle).size(150)
            // function(d) { 
              // console.log(  )
              // const cluster = d["intent_cluster"] % symbols.length
              // return symbols[cluster](d)
              
            // }
            )
            .attr("stroke", "lightslategrey")
            .attr('fill',  function (d) {
              var label = parseInt(d["intent_cluster"])
              return cluster_to_color[label]; 
            })
            .attr('transform', function(d) {
              translation = "translate(" + x(d[`${dim_reduction}-dim0`])
                   + "," + y(d[`${dim_reduction}-dim1`]) + ")";
              return translation;
            })
            .on("mouseover", show_tooltip)
            .on("mousemove", move_tooltip_to_cursor)
            .on("mouseout", hide_tooltip)
            .on("click", onclick)
            .call(drag);

          // Initialise a variable for keeping track of currently visible datapoints
          var currently_visible_dps = scatter.selectAll(".datapoint");

          // create a tooltip
          var tooltip = d3.select("#container")
            .append("div")
              .style("position", "absolute")
              .style("visibility", "hidden")
              .style("background-color", "white")
              .style("border", "2px solid black")
              .style("padding", "10px")


          // A function that updates the chart when the user zoom and thus new boundaries are available
          function updateChart() {
              // recover the new scale
              var newX = d3.event.transform.rescaleX(x);
              var newY = d3.event.transform.rescaleY(y);

              // update axes with these new boundaries
              xAxis.call(d3.axisBottom(newX))
              yAxis.call(d3.axisLeft(newY))
              
              updatePositions(newX, newY);

              var drag_link = d3.select("#drag-line-0");
              if (!drag_link.empty() && drag_link.style("visibility") == "visible") {
                drag_link
                .attr("x1", function(d) { return newX(d.x1) })
                .attr("y1", function(d) { return newY(d.y1) })
                .attr("x2", function(d) { return newX(d.x2) })
                .attr("y2", function(d) { return newY(d.y2) });
              }    
          }

          function getXYScales(data) { // TO REFACTOR: use this instead of repetition
            xMin = Math.min(...data.map(d => d[`${dim_reduction}-dim0`]));
            xMax = Math.max(...data.map(d => d[`${dim_reduction}-dim0`]));
            xRange = xMax - xMin;

            yMin = Math.min(...data.map(d => d[`${dim_reduction}-dim1`]));
            yMax = Math.max(...data.map(d => d[`${dim_reduction}-dim1`]));
            yRange = yMax - yMin;


            // Add X axis
            var x = d3.scaleLinear()
            .domain([xMin - 0.1 * xRange, xMax + 0.1 * xRange])
            .range([ 0, width ]);

            // Add Y axis
            var y = d3.scaleLinear()
            .domain([yMin - 0.1 * yRange, yMax + 0.1 * yRange])
            .range([ height, 0]);

            return [x, y];
          }

          function updatePositions(xScale, yScale) {
            // update positions
            scatter
              .selectAll("path.datapoint")
              .attr('transform', function(d) {
                translation = "translate(" + xScale(d[`${dim_reduction}-dim0`])
                    + "," + yScale(d[`${dim_reduction}-dim1`]) + ")";
                return translation;
              });
          }

          function updateCategories() {
            var [visibles, gold_intent_set, predicted_intent_set, intent_cluster_set] = getVisibleDatapoints();

            currently_visible_dps = visibles;

            if (gold_intent_set.length <= symbols.length) {
              const intents_with_symbols = Object.keys(previous_intent_symbol_map)
                                              .map(k => parseInt(k))
                                              .filter(k => gold_intent_set.includes(k));
              const intents_without_symbols = gold_intent_set.filter(
                  intent => !intents_with_symbols.includes(intent)
                );
              const used_symbols = intents_with_symbols.map(k => previous_intent_symbol_map[k]);
              const remaining_symbols = symbols.filter(sym =>
                  !used_symbols.includes(sym)
                );

              if (intents_without_symbols.length > remaining_symbols.length) {
                throw new Error("There aren't enough symbols to assign to the newly visible intents: "
                                  + `${intents_without_symbols.length} !< ${remaining_symbols.length}`);
              }


              intent_to_symbol = Object.fromEntries( intents_without_symbols.map((intent, i) => [intent, remaining_symbols[i]]) );
              currently_visible_dps
                .attr("d", function(d) {
                  const intent = d.ground_truth_label_idx;
                  if (intents_with_symbols.includes(intent)) {
                    return previous_intent_symbol_map[intent](d);
                  } else {
                    return intent_to_symbol[intent](d);
                  }
                })
              
              previous_intent_symbol_map = Object.assign(previous_intent_symbol_map, intent_to_symbol);
            } else {
              currently_visible_dps
                .attr("d", d3.symbol().type(d3.symbolCircle).size(150));
            }
          }

          var previous_intent_symbol_map = {};

          function getVisibleDatapoints() {
            var gold_intents = [];
            var predicted_intents = [];
            var intent_cluster_set = new Set([]);

            visibles = scatter.selectAll(".datapoint").filter(function(d) {
              var x = this.transform.baseVal[0].matrix.e;
              var y = this.transform.baseVal[0].matrix.f;
              
              is_visible = d3.select(this).style("visibility") == "visible"
              is_visible = is_visible && 0 < x && x < width && 0 < y && y < height;
              if (is_visible) {
                gold_intents.push(d["ground_truth_label_idx"])
                predicted_intents.push(d["prediction_label_idx"])
                intent_cluster_set.add(d["intent_cluster"])
              }
              return is_visible;
            });

            var gold_intent_set = [...new Set(gold_intents)];
            var predicted_intent_set = [...new Set(predicted_intents)];

            return [visibles, Array.from(gold_intent_set), Array.from(predicted_intent_set), Array.from(intent_cluster_set)];
          }

          function filterChart(idxs) {
              scatter.selectAll(".datapoint")
                .attr("visibility", function(d) {
                  d_idx = d["idx"]; // TO REFACTOR: use semi-colon consistently
                  
                  if (idxs.length == 0) {
                    return "visible";
                  }
                  
                  if (idxs.includes(d_idx)) {
                    return "visible";
                  } else {
                    return "hidden";
                  }
                });
          }

          function clear() {
            filter_input.val("");
            if ($("#show-errors").is(":checked")) {
              filterChart(errors_idxs);
            } else {
              filterChart([]);
            }

            $(".selected-dp")
              .attr("stroke", "darkgrey")
              .attr("stroke-width", "1px")
              .removeClass("selected-dp");
            d3.select("#drag-line-0").style("visibility", "hidden");
          }

          function show_tooltip(d) { // TO REFACTOR: use either camelCase or snake_case but not both
            move_tooltip_to_cursor();
            $(this).addClass("ismouseover");
            tooltip_html = Object.entries(d).reduce(
              (acc, current) => acc + `<p><b>${ current[0] }</b>: ${ current[1] }</p>`,
              ""
            );
            tooltip.html(tooltip_html);
            return tooltip.style("visibility", "visible");
          }

          function move_tooltip_to_cursor() { 
            return tooltip.style("top", (event.pageY + 20)+"px").style("left",(event.pageX + 20)+"px");
          }

          function hide_tooltip(){ 
            $(this).removeClass("ismouseover");
            return tooltip.style("visibility", "hidden");
          }

          /*
          Return the position of the given circle/triangle
          */
          function get_position(dp_element) {
            return [dp_element.transform.baseVal[0].matrix.e,
                    dp_element.transform.baseVal[0].matrix.f];
          }

          function onclick(d) {
            $(".selected-dp")
              .removeClass("selected-dp")
              .attr("stroke", "darkgrey")
              .attr("stroke-width", "1px");
            filter_by_dp_attr(d);
            $(this).attr("stroke", "red")
                  .attr("stroke-width","3px")
                  .addClass("selected-dp");
          }

          function filter_by_dp_attr(d) {
            if (!d) {
              return;
            }

            const filter_by = $('input[name="filter-by"]:checked').val(); 
            var idxs = [];
            if (filter_by == "support_set") {
              idxs = d[filter_by].concat([d["idx"]]);
            } else {
              data.forEach(function(dp, i) {
                if (dp[filter_by] == d[filter_by]) {
                  idxs.push(i);
                }
              });
            }
            filterChart(idxs);
          }
      })

    </script>
  </body>
</html>